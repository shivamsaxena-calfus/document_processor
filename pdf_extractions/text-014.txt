8

Programming with Actors and Messages

import scala.actors.Actor
abstract class AuctionMessage
case class Offer(bid: Int, client: Actor)
case class Inquire(client: Actor)

extends AuctionMessage
extends AuctionMessage

abstract class AuctionReply
case class Status(asked: Int, expire: Date) extends AuctionReply
case object BestOffer
extends AuctionReply
case class BeatenOffer(maxBid: Int)
extends AuctionReply
case class AuctionConcluded(seller: Actor, client: Actor)
extends AuctionReply
case object AuctionFailed
extends AuctionReply
case object AuctionOver
extends AuctionReply

Listing 3.1: Message Classes for an Auction Service

selects (using receiveWithin) a message and reacts to it, until the auction is closed,
which is signaled by a TIMEOUT message. Before finally stopping, it stays active for
another period determined by the timeToShutdown constant and replies to further
offers that the auction is closed.
Here are some further explanations of the constructs used in this program:
• The receiveWithin method of class Actor takes as parameters a time span
given in milliseconds and a function that processes messages in the mailbox.
The function is given by a sequence of cases that each specify a pattern and
an action to perform for messages matching the pattern. The receiveWithin
method selects the first message in the mailbox which matches one of these
patterns and applies the corresponding action to it.
• The last case of receiveWithin is guarded by a TIMEOUT pattern. If no other
messages are received in the meantime, this pattern is triggered after the time
span which is passed as argument to the enclosing receiveWithin method.
TIMEOUT is a special message, which is triggered by the Actor implementation
itself.
• Reply

messages

are

sent

using
syntax
of
the
form
destination ! SomeMessage. ! is used here as a binary operator with
an actor and a message as arguments. This is equivalent in Scala to the
method call destination.!(SomeMessage), i.e. the invocation of the !
method of the destination actor with the given message as parameter.

The preceding discussion gave a flavor of distributed programming in Scala. It
might seem that Scala has a rich set of language constructs that support actor processes, message sending and receiving, programming with timeouts, etc. In fact, the

