6

A First Example

For instance, “standard” binary operators such as +, -, or < are not treated in any
special way. Like append, they are methods of their left operand. Consequently, the
expression i + 1 is regarded as the invocation i.+(1) of the + method of the integer
value x. Of course, a compiler is free (if it is moderately smart, even expected) to
recognize the special case of calling the + method over integer arguments and to
generate efficient inline code for it.
For efficiency and better error diagnostics the while loop is a primitive construct in
Scala. But in principle, it could have just as well been a predefined function. Here is
a possible implementation of it:
def While (p: => Boolean) (s: => Unit) {
if (p) { s ; While(p)(s) }
}

The While function takes as first parameter a test function, which takes no parameters and yields a boolean value. As second parameter it takes a command function
which also takes no parameters and yields a result of type Unit. While invokes the
command function as long as the test function yields true.
Scala’s Unit type roughly corresponds to void in Java; it is used whenever a function does not return an interesting result. In fact, because Scala is an expressionoriented language, every function returns some result. If no explicit return expression is given, the value (), which is pronounced “unit”, is assumed. This value is
of type Unit. Unit-returning functions are also called procedures. Here’s a more
“expression-oriented” formulation of the swap function in the first implementation
of quicksort, which makes this explicit:
def swap(i: Int, j: Int) {
val t = xs(i); xs(i) = xs(j); xs(j) = t
()
}

The result value of this function is simply its last expression – a return keyword is
not necessary. Note that functions returning an explicit value always need an “=”
before their body or defining expression.

