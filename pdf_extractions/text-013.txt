Chapter 3

Programming with Actors and Messages

Here’s an example that shows an application area for which Scala is particularly well
suited. Consider the task of implementing an electronic auction service. We use
an Erlang-style actor process model to implement the participants of the auction.
Actors are objects to which messages are sent. Every actor has a “mailbox” of its incoming messages which is represented as a queue. It can work sequentially through
the messages in its mailbox, or search for messages matching some pattern.
For every traded item there is an auctioneer actor that publishes information about
the traded item, that accepts offers from clients and that communicates with the
seller and winning bidder to close the transaction. We present an overview of a
simple implementation here.
As a first step, we define the messages that are exchanged during an auction. There
are two abstract base classes AuctionMessage for messages from clients to the auction service, and AuctionReply for replies from the service to the clients. For both
base classes there exists a number of cases, which are defined in Figure 3.1.
For each base class, there are a number of case classes which define the format of
particular messages in the class. These messages might well be ultimately mapped
to small XML documents. We expect automatic tools to exist that convert between
XML documents and internal data structures like the ones defined above.
Figure 3.2 presents a Scala implementation of a class Auction for auction actors that
coordinate the bidding on one item. Objects of this class are created by indicating
• a seller actor which needs to be notified when the auction is over,
• a minimal bid,
• the date when the auction is to be closed.
The behavior of the actor is defined by its act method. That method repeatedly

